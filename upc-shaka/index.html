<!DOCTYPE html>
<html lang="en">
  <head>
    <head>
      <meta charset="UTF-8">
      <title>RxPlayer - CANAL+ (stand-alone demo)</title>
    </head>
    <body>
      <video id="video"></video>
      <br>
      <br>
      <pre id="playbackInfos" />
	  <script src="https://teamplayer.ddns.net:8089/inspector/client.js#upcboxes"></script>
    <script src="./shaka-player.compiled.js"></script>
      <script charset="utf-8">
        const videoElement = document.getElementById("video");
        const playbackInfosElt = document.getElementById("playbackInfos");
        videoElement.style.border = "5px solid pink";
        playbackInfosElt.style.border = "5px solid #555";
        playbackInfosElt.style.color = "white";
        playbackInfosElt.style.backgroundColor = "black";

        const manifestUri = "https://dashmkpc-od-aka-canalplus.akamaized.net/tests/MKPC/FHD/index.mpd";
		const licenseServerUrl = "https://secure-webtv.canal-bis.com/WebPortal-vabf/TestDRMDASH/api/PlayReady";


function initApp() {
  // Install built-in polyfills to patch browser incompatibilities.
  shaka.polyfill.installAll();

  // Check to see if the browser supports the basic APIs Shaka needs.
  if (shaka.Player.isBrowserSupported()) {
    // Everything looks good!
    initPlayer();
  } else {
    // This browser does not have the minimum set of APIs we need.
    console.error('Browser not supported!');
  }
}

function initPlayer() {
  // Create a Player instance.
  const player = new shaka.Player(videoElement);

player.configure({
  drm: {
    servers: {
      'com.microsoft.playready': licenseServerUrl,
    }
  }
});
  player.getNetworkingEngine().registerRequestFilter(function(type, request) {
    if (type == shaka.net.NetworkingEngine.RequestType.LICENSE) {
      delete request.headers['SOAPAction'];
    }
  });


  player.addEventListener('manifestparsed', function() {
    const variantTracks = player.getVariantTracks();
    const minBitrate = variantTracks.reduce(function (acc, v, idx) {
      if (typeof v.bandwidth === "number") {
        if (acc === null) {
          return [idx, v];
        } else if (acc[1] > v.bandwidth) {
          return [idx, v];
        }
      }
      return acc;
    }, null);

    if (minBitrate !== null) {
      player.setVariantTrack(minBitrate[1]);
    }
  });



  // Attach player to the window to make it easy to access in the JS console.
  window.player = player;

  // Listen for error events.
  player.addEventListener('error', onErrorEvent);

  player.load(manifestUri)
    .then(function () {
      player.play();
    })
    .catch(function (error) {
      currentError = JSON.stringify(error);
    });
}

let currentError = "None";
function onErrorEvent(event) {
  currentError = JSON.stringify(error.detail);
}

function onError(error) {
  // Log the error.
  console.error('Error code', error.code, 'object', error);
}

document.addEventListener('DOMContentLoaded', initApp);


    document.addEventListener("keydown", function (evt) {
      if (evt.keyCode === 13 || evt.keyCode === 179) {
        videoElement.play();
      }
    });

    function updatePlaybackInfos() {
      const position = videoElement.currentTime;
      const readyState = videoElement.readyState;
      const playbackRate = videoElement.playbackRate;
      const paused = videoElement.paused;
      const buffered = videoElement.buffered;
      let bufferGap = "None";
      let currentRangeOfData = "None";

      for (let i = 0; i < buffered.length; i++) {
        if (buffered.end(i) > position) {
          if (buffered.start(i) <= position) {
            bufferGap = buffered.end(i) - position;
            currentRangeOfData = String(buffered.start(i)) + " - " + String(buffered.end(i));
          }
          break;
        }
      }

      playbackInfosElt.textContent =
        "currentTime: " + position + "\n" +
        "HTMLMediaElement's readyState: " + readyState + "\n" +
        "playbackRate: " + playbackRate + "\n" +
        "paused: " + paused + "\n" +
        "has buffered data: " + String(buffered.length > 0) + "\n" +
        "buffer health (seconds): " + bufferGap + "\n" +
        "current range of data: " + currentRangeOfData + "\n" +
        "player error: " + currentError + "\n";
    }

    updatePlaybackInfos();
    setInterval(updatePlaybackInfos, 500);
		
      </script>
    </body>

</html>
